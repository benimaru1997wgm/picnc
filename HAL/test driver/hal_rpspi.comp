/*    Copyright (C) 2013 GP Orcullo
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

component hal_rpspi "Simple SPI driver for Raspberry Pi";

pin out u32	##.rx[16]	  = 0	"Receive buffer";
pin in u32	##.tx[16]	  = 0	"Transmit buffer";

description """
Usage: loadrt hal_rpspi
""";

option singleton;
option extra_setup;
option extra_cleanup;

function transfer  "transfers data between master and slave devices";

license "GPL";
author "GP Orcullo";
;;

#include "rtapi.h"
#include "rtapi_bitops.h"
#include "rtapi_app.h"
#include "hal.h"

#if !defined(BUILD_SYS_USER_DSO)
#error "This driver is for usermode threads only"
#endif

#if !defined(TARGET_PLATFORM_RASPBERRY)
#error "This driver is for the Raspberry Pi platform only"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>
#include <stdarg.h>

#include "hal_rpspi.h"

volatile unsigned *gpio, *spi;
static volatile u32 txBuf[BUFSIZE], rxBuf[BUFSIZE];

static int map_gpio();
static void setup_gpio();
static void restore_gpio();

EXTRA_SETUP() {
	int i, retval = 0;

	retval = map_gpio();
	if (retval < 0) {
		rtapi_print_msg(RTAPI_MSG_ERR,
		        "HAL_PICNC: ERROR: cannot map GPIO memory\n");
		return retval;
	}

	setup_gpio();

	return 0;
}

EXTRA_CLEANUP() {
	if (gpio != MAP_FAILED && spi != MAP_FAILED) {
		restore_gpio();
		munmap((void *)gpio,BLOCK_SIZE);
		munmap((void *)spi,BLOCK_SIZE);
	}
}

FUNCTION(transfer) {
	char *buf;
	int i;

	for (i=0; i<BUFSIZE; i++) {
		txBuf[i] = _tx(i);
	}
	/* activate transfer */
	BCM2835_SPICS = SPI_CS_TA;

	/* send txBuf */
	/* RPi SPI transfers 8 bits at a time only */
	buf = (char *)txBuf;
	for (i=0; i<SPIBUFSIZE; i++) {
		BCM2835_SPIFIFO = *buf++;
	}

	/* wait until transfer is finished */
	while (!(BCM2835_SPICS & SPI_CS_DONE));

	/* clear DONE bit */
	BCM2835_SPICS = SPI_CS_DONE;

	/* read buffer */
	/* RPi SPI transfers 8 bits at a time only */
	buf = (char *)rxBuf;
	for (i=0; i<SPIBUFSIZE; i++) {
		*buf++ = BCM2835_SPIFIFO;
	}
	for (i=0; i<BUFSIZE; i++) {
		_rx(i) = rxBuf[i];
	}
}

int map_gpio() {
	int fd;

	fd = open("/dev/mem", O_RDWR | O_SYNC);
	if (fd < 0) {
		rtapi_print_msg(RTAPI_MSG_ERR,"HAL_PICNC: can't open /dev/mem \n");
		return -1;
	}

	/* mmap GPIO */
	gpio = mmap(
	        NULL,
	        BLOCK_SIZE,
	        PROT_READ|PROT_WRITE,
	        MAP_SHARED,
	        fd,
	        BCM2835_GPIO_BASE);

	/* mmap SPI */
	spi = mmap(
	        NULL,
	        BLOCK_SIZE,
	        PROT_READ|PROT_WRITE,
	        MAP_SHARED,
	        fd,
	        BCM2835_SPI_BASE);

	close(fd);

	if (gpio == MAP_FAILED) {
		rtapi_print_msg(RTAPI_MSG_ERR,"HAL_PICNC: can't map gpio\n");
		return -2;
	}

	if (spi == MAP_FAILED) {
		rtapi_print_msg(RTAPI_MSG_ERR,"HAL_PICNC: can't map spi\n");
		return -3;
	}

	return 0;
}

void setup_gpio() {
	uint32_t x;

	/* change SPI pins */
	x = BCM2835_GPFSEL0;
	x &= ~(0b111 << (7*3) | 0b111 << (8*3) | 0b111 << (9*3));
	x |= (0b100 << (7*3) | 0b100 << (8*3) | 0b100 << (9*3));
	BCM2835_GPFSEL0 = x;

	x = BCM2835_GPFSEL1;
	x &= ~(0b111 << (0*3) | 0b111 << (1*3));
	x |= (0b100 << (0*3) | 0b100 << (1*3));
	BCM2835_GPFSEL1 = x;

	/* set up SPI */
	BCM2835_SPICLK = (1 << SPICLKDIV);

	BCM2835_SPICS = 0;

	/* clear FIFOs */
	BCM2835_SPICS |= SPI_CS_CLEAR_RX | SPI_CS_CLEAR_TX;

	/* clear done bit */
	BCM2835_SPICS |= SPI_CS_DONE;
}

void restore_gpio() {
	uint32_t x;

	/* change SPI pins to inputs*/
	x = BCM2835_GPFSEL0;
	x &= ~(0b111 << (7*3) | 0b111 << (8*3) | 0b111 << (9*3));
	BCM2835_GPFSEL0 = x;

	x = BCM2835_GPFSEL1;
	x &= ~(0b111 << (0*3) | 0b111 << (1*3));
	BCM2835_GPFSEL1 = x;
}